---
title: "Informe dinámico"
author: "Álvaro García Muñoz"
date: "`r Sys.Date()`"
bibiliography: Data/TFM.bib
biblio-style: "apalike"
output:
  html_document:
    toc: true
    toc_float: true
  pdf_document:
    latex_engine: "xelatex"
    toc: true
    number_sections: true
    fig_caption: true
---

```{r setup, include=FALSE}
path <- "/mnt/756b4178-6cf1-4cab-bdfb-8342cc4c885a/jlorsal/ANALISIS_275GB/Alvaro/06_TFM" 
knitr::opts_chunk$set(echo = TRUE) #""MAC: ~/Documents/GitHub ; Wind: C:/Users/agarm/Desktop/TFM 2.0/TFM-2.0
knitr::opts_knit$set(root.dir = path)
```

```{r librerias, include =FALSE}
library(tidyverse)
library(MASS)
library(dummy)
library(mice)
library(ggplot2)
library(umap)
library(Rtsne)
library(dbscan)
library(moments)
library(ConsensusClusterPlus)

#Working directory
  getwd()
  setwd(path)
  rm(list = ls())
set.seed(123)
```

# Introducción

En este documento concevido para el análisis de datos normalizados provenientes de protemómica usando tecnología de **Olink**, más concretamente la tecnología _NPX_ (Normalized Protein eXpression)(ref), de un archivo csv llamado _Olink.NPX_values.Inflammatory-panels.csv_. En el se describen se encuentran muestras de las proteínas de personas que han sufrido enfermedades respiratorias graves, principalmente fibrosis pulmonar idiopática y COVID-19 grave. El script desarrollado en este documento presenta un análisis de este tipo de datos junto a un conjunto de datos de los mimsas muestras con datos sobre los fenotipos de las muestras.


```{r Carga de datos, echo = FALSE}
#File reading
  path <- "data"
  fn_phenotypes<- "phenotypes.tsv"
  fn_proteins <- "Olink.NPX_values.Inflammatory-panels.csv"

  phenotypes <- read_tsv(paste(path,fn_phenotypes, sep="/"))
  proteins <- read.csv(paste(path,fn_proteins,sep="/"))
```

# Exploración de los datos

Para realizar correctamente el estudio multivariante de los datos se debe comenzar por reconocer las variables, es por ello que este primer apartado esta dedicado a la exploración de las variables. Se dividirá en 3 sub-apartados:

- Exploración de datos faltantes.
- Análisis univariante.
- Análisis multivariante.

Antes de comenzar con la exploración de los datos se observa la estructura de ambos conjuntos de datos:

```{r Estructura}
str(proteins[,10])
str(phenotypes)
```


## Exploración de datos faltantes

Para imputar los datos faltantes se realiza el siguiente procedimiento:
- Utilizar para el conjunto de proteínas el método **pmm** de la función _mice_ (ref)  del paquete del mismo nombre 

```{r Cálculo NA, message=FALSE, warning=FALSE}
m <- 5
temp <- mice(proteins, method = 'pmm', m=m, seed=23, print=FALSE)
```

Una vez realizado el análisis y el cálculo $m = `r m`$ veces se imputan en los valores en los datos faltantes:

```{r Impute}
for(i in 1:ncol(proteins)){
  index <- which(is.na(proteins[,i]))
  proteins[index, i] <- median(t(temp$imp[[i]]))
}
```

## Análisis univariante
En este apartado se procede a realizar un análisis profundo sobre las variables estudiadas.

### Proteínas

Se empezará por estudiar las provenientes de proteómica, estas serán variables ya normalizadas. El siguiente plot muestra la densidad de una muestra aleatoria de proteínas:

```{r Density protein}
index <- sample(1:ncol(proteins), 9, replace = FALSE)

  temp <- proteins[,index]
  par(mfrow=c(3,3))
  for (x in 1:ncol(temp)){
    plot(density(temp[,x]), main = paste("Density of protein number", colnames(temp)[x], sep = " "))
  }
  
```

A continuación, se desea estudiar la desviación de las diferentes variables, por lo que se usará la mediana absoluta de desviación, usaremos una muestra de `r ncol(temp)` proteínas para este estudio estudio:

```{r Classic metrics}
for (i in 1:ncol(temp)){ 
    tempt <- fivenum(temp[,i])
    q <- paste('-The quartiles of ', colnames(temp)[i], 
               '. Min:',tempt[1], 
               '. 1Q:' ,tempt[2],
               '. Median:', tempt[3],
               '. 3Q:', tempt[4],
               '. Máx:', tempt[5]
               , sep = '')
    m <- paste('-The mean of', colnames(temp)[i], 'is', mean(temp[,i], sep= ' '))
    mad <- paste("-The median absolute deviation of",colnames(temp)[i], "is", mad(temp[,i]), sep= " ")
    
    tempt <- sd(temp[,i])/mean(temp[,i])
    cv <- paste("-The coefficient of variation of",colnames(temp)[i], "is", tempt, sep= " ")
    title <- paste('Analysis of variable ', colnames(temp)[i], ':', sep = '')
    cat(title ,q, m, mad, cv, sep = "\n")   

    boxplot(temp[,i], main = paste("Boxplot of Variable", colnames(temp)[i], sep = " "))
  } 
```

Se constata que las proteínas estan distribuidas de manera similiar.

También, se desea analizar la forma de distribución de las diferentes proteínas. Para ello se usarán dos estadísticos, la __curtosis__ y el __sesgo__:

```{r Curtosis y sesgo, echo=FALSE}
kurtosis <- list('Normal' = c(), 'Leptokurtic' = c(), 'Platykurtic' = c())
  skewness <- list('Symmetric' = c(), 'Right' = c(), 'Left' = c())
  for (i in 2:ncol(proteins)){
    temp <- kurtosis(proteins[,i])
    tempt <- skewness(proteins[,i])
    
    if(temp == 3){
      kurtosis[[1]] <- cbind(kurtosis[[1]], colnames(proteins)[i])
    }
    else if(temp >3){
      kurtosis[[2]] <- cbind(kurtosis[[2]], colnames(proteins)[i])
    }
    else{
      kurtosis[[3]] <- cbind(kurtosis[[3]], colnames(proteins)[i])
    }
    
    
    if(temp == 0){
      skewness[[1]] <- cbind(skewness[[1]], colnames(proteins)[i])
    }
    else if(temp < 0){
      skewness[[2]] <- cbind(skewness[[2]], colnames(proteins)[i])
    }
    else{
      skewness[[3]] <- cbind(skewness[[3]], colnames(proteins)[i])
    }
  }
  
  N <- paste(kurtosis[[1]], sep = ", ")
  L <- paste(kurtosis[[2]], sep = ", ")
  P <- paste(kurtosis[[3]], sep = ", ")
  

  
  cat('Kurtosis lengths:', 'Normal:', length(kurtosis[[1]]), 'Leptokurtic:', length(kurtosis[[2]]), 'Platykurtic:', length(kurtosis[[3]]), sep = '\n')
  k <- c(length(kurtosis[[1]]), length(kurtosis[[2]]), length(kurtosis[[3]]))
  
  N <- paste(skewness[[1]], sep = ", ")
  L <- paste(skewness[[2]], sep = ", ")
  P <- paste(skewness[[3]], sep = ", ")
  
  cat('Skewness lengths:', 'Symmetric:', length(skewness[[1]]), 'Right:', length(skewness[[2]]), 'Left:', length(skewness[[3]]), sep = '\n')
  
  s <- c(length(skewness[[1]]), length(skewness[[2]]), length(skewness[[3]]))
```

Se constata que las variable son mayormente, _`r names(kurtosis)[which.max(k)]`_ y _`r names(skewness)[which.max(s)]`_.

### Fenotipos

Una vez realizado este pequeño análisis univariante de las proteínas se procede a realizar un análisis univariante de los datos fenotípicos. Estan son las variables que fenotípicas que se están estudiando:

_`r colnames(phenotypes)[-which(colnames(phenotypes)=='id')]`_.

Se procede a representar las variables:

```{r Phenotypes plotting}
par(mfrow = c(2,2))
  temp <- phenotypes[, -which(colnames(phenotypes)=='Age')] #Age is the only phenotype with a non-discrete distribution.
  
  for(i in 2:ncol(temp)){
    tempt <- table(temp[,i]) #Table of phenotype
    print(tempt) #Obtain table
    print(prop.table(tempt)) #Obtain prop table
    barplot(tempt, main = paste('Variable', colnames(temp)[i]),
            xlab = 'Levels', ylab = 'Quantity') #Shows a barplot
  }
  
  par(mfrow = c(1,1))
  temp <-phenotypes[, which(colnames(phenotypes) == 'Age')]
  plot(density(temp$Age), main = 'Density of variable Age')
```

Se están estudiando `r ncol(phenotypes)` variables fenotípicas. Mayoritaríamente catégoricas, además se observa que estamos estudiando `r length(table(phenotypes[,which(colnames(phenotypes)=='Diagnosis')]))` diágnosticos diferentes.



## Análisis bivariante

A continuación se procede a realizar un estudio bivariado de las diferentes variables a estudiar.

### Modelos lineales

Se estudia la la correlacción de las proteínas con el objetivo de escoger las de mayor correlacción para realizar una regresión lineal:

```{r Correlacción}
cr <- cor(proteins[,-1])
temp1 <- c()
for(i in 1:ncol(cr)){
  for(j in i:nrow(cr)){
    if(abs(cr[i,j]) >0.95 && i!=j){
      temp1 <- rbind(temp1, c(i,j))
    }
  }
}

```

En total obtenemos `r nrow(temp1)` pares de proteínas con una alta correlacción. Se procede a mostrar una regresión lineal de una muestra aleatoria de estas proteínas:


```{r Regresion}
temp<-sample(1:nrow(temp1), 9)
temp1 <- temp1[temp,]


par(mfrow=c(3,3))
for(i in 1:nrow(temp1)){
  data <- data.frame("x" =proteins[,temp1[i,1]+1], "y"=proteins[,temp1[i,2]+1])
  
  a<-ggplot(aes(x, y), data = data) +
    geom_point()+
    geom_smooth(method = "lm", se = TRUE)+
    xlab(paste('Protein',colnames(proteins)[temp1[i,1]+1]))+
    ylab(paste('Protein',colnames(proteins)[temp1[i,2]+1]))+
    theme_light()
  plot(a)
}
```


### Covarianza proteínas

Se estudia la covarianza de las proteínas

```{r Covarianza}
temp <- cov(proteins[,-1])

for(i in 1:nrow(temp)){
  for(j in i:ncol(temp)){
    if(!(i==j) & abs(temp[i,j])>0.9){
      proteins <- proteins[,-(j+1)]
    }
  }
}

knitr::kable(temp[1:20,1:20])
```

Para su análisis se han eliminado una serie de proteínas según su covarianza. Esto es debido al desequilibrio de ligamiento y se ha puesto como corte un valor de $0.9$. Es decir, de aquellas covarianzas que superen el $0.9$ de covarianza se ha eliminado una de ellas.


# Agrupamiento de los datos

Se procede a realizar el escalado multidimensional con diferentes distancias para realizar una comparación entre los individuos. Pero para ello primero se ajustan los datos, vamos a transformar la matriz de fenotipos.

```{r Phenotypes management}
#Al ser fenotipos deseo tratarlo como diferentes dimensiones no como si uno fuera x veces en la misma dimension

phenotypes$Diagnosis <- as.factor(phenotypes$Diagnosis)
phenotypes$Site <- as.factor(phenotypes$Site)
phenotypes$Sex <- as.factor(phenotypes$Sex)

temp <- dummy(phenotypes[,-1], int = TRUE)
temp1 <- cbind('Age' = phenotypes$Age, temp)
phenotypes.int<- cbind(phenotypes[,1], temp1)
```

Una vez ajustada la matriz de fenotipos a una matriz numérica se porcede a combinarla con la matriz de proteínas. Se obtendran 3 matrices sujetas a estudio: 
- __EM (Extended matrix)__: Esta será la matriz que guardará todos los datos y la principal matriz sometida a estudio

- __Proteins.nb (Proteins new base)__: Esta será la matriz que contendrá la información proteíca de los individuos definida en una base sin covarianza entre los individuos. 

- __Data___: Esta será una matriz sin la variable _Diagnosis_ utilizada para los agrupamientos supervisados.

```{r Agrupamiento matricial}
labels <- subset(phenotypes, select = c(id, Diagnosis))

proteins.nb <- proteins
rownames(proteins.nb) <- proteins.nb$id


em <- merge(proteins.nb, phenotypes.int, by='id')


proteins.nb <-scale(proteins.nb[,-which(colnames(proteins.nb) == "id")])
em <- scale(em[,-1])

data <- em[,-grep('Diagnosis',colnames(em))]
rownames(data) <- rownames(em)
data <- scale(data[,-1])
```



# Distancias

En este punto se procede a realizar un estudio usando el escalado dimensional con la definición de diferentes distancias que permitan visualizar las diferencias entre grupos. Es remarcable decir que las métricas usadas no serán equivalentes puesto permitirá encontrar escalados variados.

## Distancia Euclidea

Se comenzará por estudiar mediante la distancia clásica por excelencia, la distancia euclidea. Calculamos la matriz de distancia euclídea entre los individuos:

```{r Distancia euclidea, message=FALSE}

dist.prot.nb <- dist(proteins.nb)
dist.em <- dist(em)
dist.data <- dist(data)

par(mfrow=c(1,3))

eu.prot.nb<-cmdscale(dist.prot.nb)
eqscplot(eu.prot.nb, main = "MDS Euclidean distance of Proteins")

eu.em<-cmdscale(dist.em)
eqscplot(eu.em, main = "MDS Euclidean distance of Extended Matrix")

eu.data<-cmdscale(dist.data)
eqscplot(eu.data, main = "MDS Euclidean distance of Data")
```


## Distancia Pearson

De forma análogica se observa el MDS utilizando la distancia de Pearson de fórmula $d(x,y) = 1-cor(x,y))$.


```{r Pearson}
dist.prot.nb <- 1 - cor(proteins.nb)
dist.em <-1 - cor(em)
dist.data <-1 - cor(data)

par(mfrow=c(1,3))

eu.prot.nb<-cmdscale(dist.prot.nb)
eqscplot(eu.prot.nb, main = "MDS Pearson distance of Proteins")

eu.em<-cmdscale(dist.em)
eqscplot(eu.em, main = "MDS Pearson distance of Extended Matrix")

eu.data<-cmdscale(dist.data)
eqscplot(eu.data, main = "MDS Pearson distance of Data")
```

Justamente estas la definición de estas dos métricas es interesante ya que no son métricas equivalentes.


## Distancia Canberra

A continuación, se procede a mostrar el MDS de una métrica equivalente a la euclídea.

```{r Distancia Canberra}
dist.prot.nb <- dist(proteins.nb, method = 'canberra')
dist.em <- dist(em, method = 'canberra' )
dist.data <- dist(data, method = 'canberra')

par(mfrow=c(1,3))

eu.prot.nb<-cmdscale(dist.prot.nb)
eqscplot(eu.prot.nb, main = "MDS Canberra distance of Proteins")

eu.em<-cmdscale(dist.em)
eqscplot(eu.em, main = "MDS Canberra distance of Extended Matrix")

eu.data<-cmdscale(dist.data)
eqscplot(eu.data, main = "MDS Canberra distance of Data")

```

Estas gráficas son los escalados multidimensionales de de diferentes distancias que pueden mostrar agrupamientos de las diferentes variables.


# Clustering methods

En este apartado se utilizaran una serie de métodos para encontrar agrupamientos siguiendo diferentes algoritmos y se mostrarán usando métodos de reducciónd de dimensiones. Los algoritmos de agrupamiento que se utilizarán son:

- K-means.
- HDBScan.

Y los métodos de reducción de dimensiones que se utilizarán son:

- UMAP.
- t-SNE.

## Reducción de dimensiones

Se procede a calcular las coordenadas de ambos métodos de reducción de dimensiones.

### UMAP

Se usa UMAP para la reducción de dimensiones.

```{r UMAP layout}
em.umap <-umap(em)
data.umap <-umap(data)
proteins.umap <- umap(proteins.nb)
```

Se observan los resultados.

```{r UMAP plot}
par(mfrow=c(1,3))

eqscplot(em.umap$layout, main = "UMAP Extended Matrix")
eqscplot(data.umap$layout, main = "UMAP Data")
eqscplot(proteins.umap$layout, main = "UMAP Proteins")
```

### T-SNE

Se usa t-SNE para la reducción de dimensiones.

```{r t-SNE layout}
em.tsne <- Rtsne(em)
data.tsne <- Rtsne(data)
proteins.tsne <- Rtsne(proteins.nb)
```

Se muestrán los resultados:

```{r t-SNE plot}
par(mfrow=c(1,3))

eqscplot(em.tsne$Y, main = "t-sne Extended Matrix")
eqscplot(data.tsne$Y, main = "t-sne Data")
eqscplot(proteins.tsne$Y, main = "t-sne Proteins")
```


## Agrupamientos no supervisados

Se procede a realizar agrupamientos no supervisados.

### K-means

Se procede a realizar el agrupamiento usando k-means.

```{r k-means}
k = 6 #Ajustar según los agrupamientos observados
em.kmeans <- kmeans(em, centers = k)
data.kmeans <- kmeans(data, centers = k)
proteins.kmeans <- kmeans(proteins.nb, centers = k)
```

Se muestrán los resultados usando UMAP.

```{r kmeans UMAP}
par(mfrow=c(1,3))

eqscplot(em.umap$layout, col =em.kmeans$cluster, main = "UMAP Extended Matrix (k-means)")
eqscplot(data.umap$layout, col =data.kmeans$cluster, main = "UMAP Data (k-means)")
eqscplot(proteins.umap$layout, col =proteins.kmeans$cluster, main = "UMAP Proteins (k-means)")
```


Se muestrán los resultados del agrupamiento usando t-SNE.

```{r kmeans tsne}
par(mfrow=c(1,3))

eqscplot(em.tsne$Y, col =em.kmeans$cluster, main = "t-sne Extended Matrix (k-means)")
eqscplot(data.tsne$Y, col =data.kmeans$cluster, main = "t-sne Data (k-means)")
eqscplot(proteins.tsne$Y, col = proteins.kmeans$cluster, main = "t-sne Proteins (k-means)")
```



### HDBScan

Se procede a realizar el agrupamiento de las tres matrices usando HDBScan.

```{r HDBScan}
  pts = 5 #Ajustar para diferentes resultados

  em.hdbscan <- hdbscan(em, minPts = pts)
  data.hdbscan <- hdbscan(data, minPts = pts)
  proteins.hdbscan <- hdbscan(proteins.nb, minPts = pts)
```

Se muestrán los resultados del agrupamiento usando UMAP.

```{r hdbscan UMAP}
par(mfrow=c(1,3))

eqscplot(em.umap$layout, col =em.hdbscan$cluster, main = "UMAP Extended Matrix (HDBScan)")
eqscplot(data.umap$layout, col =data.hdbscan$cluster, main = "UMAP Data (HDBScan)")
eqscplot(proteins.umap$layout, col =proteins.hdbscan$cluster, main = "UMAP Proteins (HDBScan)")
```

Se muestrán los resultados del agrupamiento usando t-SNE.

```{r hdbscan tsne}
par(mfrow=c(1,3))

eqscplot(em.tsne$Y, col =em.hdbscan$cluster, main = "t-sne Extended Matrix (HDBScan)")
eqscplot(data.tsne$Y, col =data.hdbscan$cluster, main = "t-sne Data (HDBScan)")
eqscplot(proteins.tsne$Y, col =proteins.hdbscan$cluster, main = "t-sne Proteins (HDBScan)")
```


# Conclusiones

Este documento pretende facilitar el estudio de datos de proteómica de alta precisión usando tecnología Olink. Sin embargo las conclusiones han de extraerse de manera análoga comprobando los resultados obtenidos. Además también es altamente recomendado continuar con los análisis para encontrar más datos.

